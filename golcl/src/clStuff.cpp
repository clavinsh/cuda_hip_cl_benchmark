#include "clStuff.h"
#include <CL/cl_ext.h>
#include <fstream>

// metode OpenCL kļūdu kodu pārveidei uz tekstu, iedvesmojoties no hashcat val2cstr_cl
// https://github.com/hashcat/hashcat/blob/master/src/ext_OpenCL.c
std::string ClErrorCodesToString(cl_int clError)
{
#define CLERR(a)                                                                                                       \
	case a:                                                                                                            \
		return #a

	switch (clError)
	{
		CLERR(CL_SUCCESS);
		CLERR(CL_BUILD_PROGRAM_FAILURE);
		CLERR(CL_COMPILE_PROGRAM_FAILURE);
		CLERR(CL_COMPILER_NOT_AVAILABLE);
		CLERR(CL_DEVICE_NOT_FOUND);
		CLERR(CL_DEVICE_NOT_AVAILABLE);
		CLERR(CL_DEVICE_PARTITION_FAILED);
		CLERR(CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST);
		CLERR(CL_IMAGE_FORMAT_MISMATCH);
		CLERR(CL_IMAGE_FORMAT_NOT_SUPPORTED);
		CLERR(CL_INVALID_ARG_INDEX);
		CLERR(CL_INVALID_ARG_SIZE);
		CLERR(CL_INVALID_ARG_VALUE);
		CLERR(CL_INVALID_BINARY);
		CLERR(CL_INVALID_BUFFER_SIZE);
		CLERR(CL_INVALID_BUILD_OPTIONS);
		CLERR(CL_INVALID_COMMAND_QUEUE);
		CLERR(CL_INVALID_COMPILER_OPTIONS);
		CLERR(CL_INVALID_CONTEXT);
		CLERR(CL_INVALID_DEVICE);
		CLERR(CL_INVALID_DEVICE_PARTITION_COUNT);
		CLERR(CL_INVALID_DEVICE_QUEUE);
		CLERR(CL_INVALID_DEVICE_TYPE);
		CLERR(CL_INVALID_EVENT);
		CLERR(CL_INVALID_EVENT_WAIT_LIST);
		CLERR(CL_INVALID_GLOBAL_OFFSET);
		CLERR(CL_INVALID_GLOBAL_WORK_SIZE);
		CLERR(CL_INVALID_HOST_PTR);
		CLERR(CL_INVALID_IMAGE_DESCRIPTOR);
		CLERR(CL_INVALID_IMAGE_FORMAT_DESCRIPTOR);
		CLERR(CL_INVALID_IMAGE_SIZE);
		CLERR(CL_INVALID_KERNEL);
		CLERR(CL_INVALID_KERNEL_ARGS);
		CLERR(CL_INVALID_KERNEL_DEFINITION);
		CLERR(CL_INVALID_KERNEL_NAME);
		CLERR(CL_INVALID_LINKER_OPTIONS);
		CLERR(CL_INVALID_MEM_OBJECT);
		CLERR(CL_INVALID_OPERATION);
		CLERR(CL_INVALID_PIPE_SIZE);
		CLERR(CL_INVALID_PLATFORM);
		CLERR(CL_INVALID_PROGRAM);
		CLERR(CL_INVALID_PROGRAM_EXECUTABLE);
		CLERR(CL_INVALID_PROPERTY);
		CLERR(CL_INVALID_QUEUE_PROPERTIES);
		CLERR(CL_INVALID_SAMPLER);
		CLERR(CL_INVALID_SPEC_ID);
		CLERR(CL_INVALID_VALUE);
		CLERR(CL_INVALID_WORK_DIMENSION);
		CLERR(CL_INVALID_WORK_GROUP_SIZE);
		CLERR(CL_INVALID_WORK_ITEM_SIZE);
		CLERR(CL_KERNEL_ARG_INFO_NOT_AVAILABLE);
		CLERR(CL_LINK_PROGRAM_FAILURE);
		CLERR(CL_LINKER_NOT_AVAILABLE);
		CLERR(CL_MAP_FAILURE);
		CLERR(CL_MEM_COPY_OVERLAP);
		CLERR(CL_MEM_OBJECT_ALLOCATION_FAILURE);
		CLERR(CL_MISALIGNED_SUB_BUFFER_OFFSET);
		CLERR(CL_OUT_OF_HOST_MEMORY);
		CLERR(CL_OUT_OF_RESOURCES);
		CLERR(CL_MAX_SIZE_RESTRICTION_EXCEEDED);
		CLERR(CL_PROFILING_INFO_NOT_AVAILABLE);
		CLERR(CL_INVALID_COMMAND_BUFFER_KHR);
		CLERR(CL_INVALID_SYNC_POINT_WAIT_LIST_KHR);
		CLERR(CL_INCOMPATIBLE_COMMAND_QUEUE_KHR);
		CLERR(CL_INVALID_MUTABLE_COMMAND_KHR);
		// CLERR(CL_INVALID_D3D10_DEVICE_KHR);
		// CLERR(CL_INVALID_D3D10_RESOURCE_KHR);
		// CLERR(CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR);
		// CLERR(CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR);
		// CLERR(CL_INVALID_D3D11_DEVICE_KHR);
		// CLERR(CL_INVALID_D3D11_RESOURCE_KHR);
		// CLERR(CL_D3D11_RESOURCE_ALREADY_ACQUIRED_KHR);
		// CLERR(CL_D3D11_RESOURCE_NOT_ACQUIRED_KHR);
		// CLERR(CL_INVALID_DX9_MEDIA_ADAPTER_KHR);
		// CLERR(CL_INVALID_DX9_MEDIA_SURFACE_KHR);
		// CLERR(CL_DX9_MEDIA_SURFACE_ALREADY_ACQUIRED_KHR);
		// CLERR(CL_DX9_MEDIA_SURFACE_NOT_ACQUIRED_KHR);
		// CLERR(CL_EGL_RESOURCE_NOT_ACQUIRED_KHR);
		// CLERR(CL_INVALID_EGL_OBJECT_KHR);
		CLERR(CL_INVALID_GL_OBJECT);
		// CLERR(CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR);
		CLERR(CL_PLATFORM_NOT_FOUND_KHR);
		CLERR(CL_INVALID_SEMAPHORE_KHR);
		CLERR(CL_CONTEXT_TERMINATED_KHR);
	}

#undef CLERR

	return "UNKOWN CL ERROR (value " + std::to_string(clError) + ")";
}

// funkcija paredzēta OpenCL kodolu failu atvēršanai un satura (pirmkoda) iegūšanai
std::string readKernelFile(const std::string &fileName)
{
	std::ifstream file(fileName);
	if (!file.is_open())
	{
		throw std::runtime_error("Failed to open kernel file: " + fileName);
	}

	std::stringstream sourceCodeBuffer;

	sourceCodeBuffer << file.rdbuf();
	return sourceCodeBuffer.str();
}
